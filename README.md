<h1>Most Important Design Patterns</h1>

<p>In This Project I've Demonstrated The 7 Most Important Design Patterns:</p>

<ul>
	<li>Singleton</li>
	<li>Factory</li>
	<li>Strategy</li>
	<li>Observer</li>
</ul>

<hr/>

<h2>Singleton Pattern</h2>
<p>In This Pattern We Should Only Have One Instance Of A Class So For Doing That<br/> 
We Make Our Class's Constructor Private And We Make A Static Instance From <br/>Our Class And 
A Static Method For Returning That Static Instance.</p>

<hr/>

<h2>Factory Pattern</h2>
<p>In This Pattern We Create Objects Without Specifying The Exact Class Of The Object<br/>
 To Be Created. To Accomplish This, Objects Are Created By Calling A Factory Method Instead<br/>
 Of Calling A Constructor And We Refer To Newly Created Object Using A Common Interface.</p>
 
 <hr/>
 
 <h2>Strategy Pattern</h2>
 <p>In This Pattern, We Create Objects Which Represent Various Strategies And A Context<br/>
 Object Whose Behavior Varies As Per Its Strategy Object. The Strategy Object Changes The<br/>
 Executing Algorithm Of The Context Object.</p>
 
 <hr/>
 
 <h2>Observer Pattern</h2>
 <p>This Pattern Consists Of Two Actors, <i>The Observer</i> Who Is Interested In The Updates</br>
 And <i>The Subject</i> Who Generated The Updates So If Subject Is Modified All Its Dependent<br/>
 Objects (Observers) Are Notified.</p>
 
 <hr/>
 
 <h2>Builder Pattern</h2>
 <p>This Pattern Is Used To Build Objects. The Exercise Of Creating Complex Types Can Be Simplified<br/>
 By Using The Builder Pattern. A Composite Or An Aggregate Object Is What A Builder Generally Builds.</p>
 
 <hr/>
 
 <h2>Adapter Pattern</h2>
 <p>This Pattern Allows Incompatible Classes To Work Together By Converting The Interface<br/>
 Of One Class Into Another. This Pattern Involves A Single Class Which Is Responsible To Join<br/>
 Functionalities Of Independent Or Incompatible Interfaces.</p>
 
 <hr/>
 
 
 
 